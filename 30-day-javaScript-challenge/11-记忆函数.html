<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>记忆函数</title>
	</head>
	<body>
		<script>
			/*
      请你编写一个函数 fn，它接收另一个函数作为输入，并返回该函数的 记忆化 后的结果。
      记忆函数 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。
      你可以假设有 3 个可能的输入函数：sum 、fib 和 factorial 。
      sum 接收两个整型参数 a 和 b ，并返回 a + b 。假设如果参数 (b, a) 已经缓存了值，其中 a != b，它不能用于参数 (a, b)。例如，如果参数是 (3, 2) 和 (2, 3)，则应进行两个单独的调用。
      fib 接收一个整型参数 n ，如果 n <= 1 则返回 1，否则返回 fib (n - 1) + fib (n - 2)。
      factorial 接收一个整型参数 n ，如果 n <= 1 则返回  1 ，否则返回 factorial(n - 1) * n 。

      示例 1：
      输入：
      fnName = "sum"
      actions = ["call","call","getCallCount","call","getCallCount"]
      values = [[2,2],[2,2],[],[1,2],[]]
      输出：[4,4,1,3,2]
      解释：
      const sum = (a, b) => a + b;
      const memoizedSum = memoize(sum);
      memoizedSum (2, 2);// "call" - 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。
      memoizedSum (2, 2);// "call" - 返回 4。没有调用 sum()，因为前面有相同的输入。
      // "getCallCount" - 总调用数： 1
      memoizedSum(1, 2);// "call" - 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。
      // "getCallCount" - 总调用数： 2

      示例 2：
      输入：
      fnName = "factorial"
      actions = ["call","call","call","getCallCount","call","getCallCount"]
      values = [[2],[3],[2],[],[3],[]]
      输出：[2,6,2,2,6,2]
      解释：
      const factorial = (n) => (n <= 1) ? 1 : (n * factorial(n - 1));
      const memoFactorial = memoize(factorial);
      memoFactorial(2); // "call" - 返回 2。
      memoFactorial(3); // "call" - 返回 6。
      memoFactorial(2); // "call" - 返回 2。 没有调用 factorial()，因为前面有相同的输入。
      // "getCallCount" -  总调用数：2
      memoFactorial(3); // "call" - 返回 6。 没有调用 factorial()，因为前面有相同的输入。
      // "getCallCount" -  总调用数：2

      示例 3：
      输入：
      fnName = "fib"
      actions = ["call","getCallCount"]
      values = [[5],[]]
      输出：[8,1]
      解释：
      fib(5) = 8 // "call"
      // "getCallCount" - 总调用数：1
    */

			function memoize(fn) {
				let map = new Map();
				return function (...args) {
					const key = args.join();
					if (!map.has(key)) {
						map.set(key, fn(...args));
					}
					return map.get(key);
				};
			}

			const memoizedSum = memoize((a, b) => a + b);
			console.log(memoizedSum(2, 2));
			console.log(memoizedSum(2, 2));
			console.log(memoizedSum(1, 2));

			console.log("======================");

			const factorial = (n) => (n <= 1 ? 1 : n * factorial(n - 1));
			const memoFactorial = memoize(factorial);
			console.log(memoFactorial(2));
			console.log(memoFactorial(3));
			console.log(memoFactorial(2));
			console.log(memoFactorial(3));

			console.log("======================");

			const fib = (n) => {
				if (n === 1 || n === 2) {
					return n - 1;
				}
				return fib(n - 2) + fib(n - 1);
			};
			const fibAction = memoize(factorial);
			console.log(fibAction(5));
			console.log(fibAction(5));
			console.log(fibAction(2));
		</script>
	</body>
</html>
